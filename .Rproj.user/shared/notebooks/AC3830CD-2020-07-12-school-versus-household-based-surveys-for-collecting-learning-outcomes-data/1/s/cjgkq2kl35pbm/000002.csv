"0","# Create a new dataframe with only children 8-11 and all the variables we want to use in our analysis"
"0","kids <- ihds %>% "
"0","  filter(!is.na(TA8B)) %>% "
"0","  transmute(ASER4, TA4, RO3, URBAN2011, ASSETS, log_inc = log(INCOME+1), group = as_factor(GROUPS), RO5, HHEDUC, NPERSONS, log_pcc = log(COPC), private = ifelse((CS4 ==4), 1, 0))"
"2","NaNs produced"
"0","# Create a formula that we will use in our probit regression later"
"0","rx <- as.formula(""ASER4 ~ TA4 + log_pcc + RO3 + RO5 + HHEDUC + private + NPERSONS + URBAN2011 + log_inc + group"")"
"0",""
"0","# 1/rho is the proportion of the main sample that we assume will be sub-sampled"
"0","rho <- 20"
"0",""
"0","# set the seed so this is reproducible"
"0","set.seed(123456789)"
"0",""
"0","# Create a 20-fold split. Note that ideally, I would randomly select households to be included/excluded in each split, but this is a pain and wouldn't likely make much of a difference. (Since IHDS only surveyed kids 8-11 there are typically max 1 per hh.)"
"0","split_obj <- vfold_cv(kids, v = rho, repeats = 10)"
"0",""
"0","# Calculate the true overall mean"
"0","true <- mean(kids$ASER4)"
"0",""
"0","# Create a function which will take one of the splits from the split_obj and calculate "
"0","# the error assuming we don't use an auxiliary info and using auxiliary information."
"0","# See here for more info https://rsample.tidymodels.org/articles/Working_with_rsets.html"
"0","ggreg_error <- function(splits){"
"0","  # Please note that I use the assessment data as the training data and the analysis test "
"0","  # as the holdout data.  This is the exact opposite of what a normal ML work flow looks like."
"0","  # In a normal workflow, you fit your model on the 1-1/rho of the data and "
"0","  #then test it on the 1/rho portion of the data.  I want to do the exact opposite. "
"0","  sample <- assessment(splits)"
"0","  other <- analysis(splits)"
"0","  "
"0","  # Fit the model  "
"0","  mod <- glm(rx, data = sample, family = binomial(link = ""probit""))"
"0","  "
"0","  # Generate model predictions for both datasets"
"0","  preds_other <- augment(mod, newdata = other, type.predict = ""response"")"
"0","  preds_sample <- augment(mod, newdata = sample, type.predict = ""response"")"
"0",""
"0","  # Calculate the generalized GREG (see Pfefferman eq 4.8 for details)"
"0","  ggreg <- mean(preds_other$.fitted, na.rm = TRUE)*((rho-1)/rho) + mean(sample$ASER4, na.rm = TRUE)/rho "
"0",""
"0","  # Return   "
"0","  return(list(true-ggreg, true- mean(sample$ASER4, na.rm=TRUE)))"
"0","}"
"0",""
"0","# Map this function to the split object"
"0","split_obj$error <- map(split_obj$splits, ggreg_error)"
"0",""
"0","# Get the root mean squared error for both the simple mean and the generalized GREG estimator"
"0","ggreg_error_vec <- map_dbl(split_obj$error, 1)"
"0","simple_error_vec <- map_dbl(split_obj$error, 2)"
"0",""
"0","sqrt_mse_ggreg <- (mean(ggreg_error_vec^2))^.5"
"0","sqrt_mse_ggreg"
"1","[1]"
"1"," 0.01969"
"1","
"
"0","sqrt_mse_simple <- (mean(simple_error_vec^2))^.5"
"0","sqrt_mse_simple"
"1","[1]"
"1"," 0.02088427"
"1","
"
